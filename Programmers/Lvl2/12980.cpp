// 점프와 순간 이동
// https://programmers.co.kr/learn/courses/30/lessons/12980

#include <iostream>
#include <algorithm>
using namespace std;

int solution(int n)
{
    int ans = 0;
    while(n > 0) {
        ans += n % 2;
        n /= 2;
    }
    return ans;
}

// 지점 0에서 지점 n까지 이동하기 위해 건전지를 1 소모하는 1칸 점프, 소모하지 않는 현재 지점 * 2 순간이동을 할 수 있을 때, 최소 비용은?

// n이 10억까지이므로 bfs나 다익스트라로 접근하기는 껄끄러움
// 사실 이 문제는 비트와 연관이 있음 - 실제로 문제의 답은 2진수로 만들었을 때 1의 갯수
// 1(1) -> +1 = 1
// 2(10) -> +1*2 = 1
// 3(11) -> +1*2+1 = 2
// 4(100) -> +1*2*2 = 1
// 5(101) -> +1*2*2+1 = 2
// 6(110) -> +1*2+1*2 = 2
// 7(111) -> +1*2+1*2+1 = 3
// 이를 보면 알 수 있듯, *2는 앞의 자리로 이동하는 것, +1은 해당 자리를 1로 만드는 것과 같음
// 만약 n이 여유로워서 다익스트라 기반으로 풀었어도 같은 결과가 나왔을 것