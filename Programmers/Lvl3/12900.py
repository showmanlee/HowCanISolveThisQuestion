# 2 x n 타일링
# https://programmers.co.kr/learn/courses/30/lessons/12900

def solution(n):
    answer = 1
    p = [1, 1]
    for i in range(2, n + 1):
        p.append((p[i - 2] + p[i - 1]) % 1000000007) 
        answer = p[i]
    return answer

# 이 경우에는 상황의 역순으로 풀어보거나 케이스를 나열해서 규칙을 찾아본다
# 칸이 하나만 남았다면 경우는 (|) 1
# 칸이 2개 남았다면 경우는 (||, =) 2
# 칸이 3개 남았다면 경우는 (|||, |=, =|) 3
# 칸이 4개 남았다면 경우는 (||||, ||=, |=|, =||, ==) 5
# 칸이 5개 남았다면 경우는 (|||||, |||=, ||=|, |=||, =|||, |==, =|=, ==|) 8
# 피보나치 수열과 같음 (p(n) = p(n-1) + p(n-2), p(n<=1) = 1)
# 그러나 재귀함수 넣으면 런타임 에러 발생하니 dp를 활용한 반복문으로 처리
# + 마지막에 나머지 계산하면 큰 수 계산때문에 막히니 매 순간마다 나머지 처리 - 어차피 덧셈이니까 나머지는 빼도 됨
# 이것이 다이나믹 프로그래밍(동적 계획법), p에 값을 넣는 건 메모이제이션 기법(계산값을 저장해서 추가 계산 방지).