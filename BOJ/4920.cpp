// 테트리스 게임
// https://www.acmicpc.net/problem/4920

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<int, int> pr;

pr block[5][4][4] = {
	{{{0, 0}, {1, 0}, {2, 0}, {3, 0}}, {{0, 0}, {0, 1}, {0, 2}, {0, 3}}, {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}}, {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}}},
	{{{0, 0}, {0, 1}, {1, 1}, {1, 2}}, {{0, 0}, {-1, 0}, {-1, 1}, {-2, 1}}, {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}}, {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}}},
	{{{0, 0}, {0, 1}, {0, 2}, {1, 2}}, {{0, 0}, {-1, 0}, {-2, 0}, {-2, 1}}, {{0, 0}, {0, -1}, {0, -2}, {-1, -2}}, {{0, 0}, {1, 0}, {2, 0}, {2, -1}}},
	{{{0, 0}, {0, 1}, {1, 1}, {0, 2}}, {{0, 0}, {-1, 0}, {-1, 1}, {-2, 0}}, {{0, 0}, {0, -1}, {-1, -1}, {0, -2}}, {{0, 0}, {1, 0}, {1, -1}, {2, 0}}},
	{{{0, 0}, {0, 1}, {1, 0}, {1, 1}}, {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}}, {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}}, {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}}}
};

int main(void) {
	cin.tie(NULL);
	ios_base::sync_with_stdio(false);

	int num = 1;
	while (true) {
		int n;
		cin >> n;
		if (n == 0)
			break;
		vector<vector<int>> board(n, vector<int>(n));
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				cin >> board[i][j];
		int res = -987654321;

		for (int x = 0; x < n; x++) {
			for (int y = 0; y < n; y++) {
				for (int t = 0; t < 5; t++) {
					for (int r = 0; r < 4; r++) {
						if (block[t][r][0].first == -1)
							break;
						int sum = 0;
						for (int b = 0; b < 4; b++) {
							int xx = x + block[t][r][b].first;
							int yy = y + block[t][r][b].second;
							if (xx < 0 || yy < 0 || xx >= n || yy >= n) {
								sum = -987654321;
								break;
							}
							sum += board[xx][yy];
						}
						res = max(sum, res);
					}
				}
			}
		}
		cout << num << ". " << res << '\n';
		num++;
	}
}

// 숫자가 적힌 n*n 보드에 테트리스 조각을 놓을 때 얻을 수 있는 네 수의 합의 최댓값은?

// 우선 조각들이 회전해서 가질 수 있는 형태를 저장 - 5가지 타입, 4가지 회전, 이들이 차지하는 블록의 상대적 위치
// 4가지 미만의 회전형을 가지는 블록은 마지막 다음 회전형의 첫 위치값을 -1로 지정하여 더 이상 탐색하지 못하게 처리
// 이후 브루트포스를 돌리면서 보드에 완전히 들어가는 형태일 때에 한해 네 칸의 합을 구한 후 결과 갱신하기
// n^2 * 13(2 + 2 + 4 + 4 + 1) -> 최대 13만 회(칸으로 접근 시 52만 회)니까 브포로 접근 가능

// 블록을 회전할 수는 있으나 뒤집을 수 없음에 주의 - S, L형은 이 문제에 나올 수 없음
// 음수도 나올 수 있음에 주의 - 초기값을 0이 아닌 불가능한 음수(-4백만 미만)로 설정해야 함