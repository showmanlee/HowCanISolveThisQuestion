// 주사위 윷놀이
// https://www.acmicpc.net/problem/17825

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int board[33][6] = {
	{0, 1, 2, 3, 4, 5},             // 0
	{2, 2, 3, 4, 5, 6},             // 1
	{4, 3, 4, 5, 6, 7},             // 2
	{6, 4, 5, 6, 7, 8},             // 3
	{8, 5, 6, 7, 8, 9},             // 4
	{10, 21, 22, 23, 29, 30},       // 5 -> 21
	{12, 7, 8, 9, 10, 11},          // 6
	{14, 8, 9, 10, 11, 12},         // 7
	{16, 9, 10, 11, 12, 13},        // 8 
	{18, 10, 11, 12, 13, 14},       // 9
	{20, 24, 25, 29, 30, 31},       // 10 -> 24
	{22, 12, 13, 14, 15, 16},       // 11
	{24, 13, 14, 15, 16, 17},       // 12
	{26, 14, 15, 16, 17, 18},       // 13
	{28, 15, 16, 17, 18, 19},       // 14
	{30, 26, 27, 28, 29, 30},       // 15 -> 26
	{32, 17, 18, 19, 20, 32},       // 16
	{34, 18, 19, 20, 32, 32},       // 17
	{36, 19, 20, 32, 32, 32},       // 18
	{38, 20, 32, 32, 32, 32},       // 19
	{40, 32, 32, 32, 32, 32},       // 20 -> 32
	{13, 22, 23, 29, 30, 31},       // 21
	{16, 23, 29, 30, 31, 20},       // 22
	{19, 29, 30, 31, 20, 32},       // 23 -> 29
	{22, 25, 29, 30, 31, 20},       // 24
	{24, 29, 30, 31, 20, 32},       // 25 -> 29
	{28, 27, 28, 29, 30, 31},       // 26
	{27, 28, 29, 30, 31, 20},       // 27
	{26, 29, 30, 31, 20, 32},       // 28 -> 29
	{25, 30, 31, 20, 32, 32},       // 29
	{30, 31, 20, 32, 32, 32},       // 30
	{35, 20, 32, 32, 32, 32},       // 31 -> 20
	{0, 32, 32, 32, 32, 32}         // 32
};

int res;
int moves[10];
int turns[10];

int simulate() {
	int ret = 0;
	vector<int> pos(4);
	for (int i = 0; i < 10; i++) {
		int t = turns[i];
		int m = moves[i];
		int np = board[pos[t]][m];
		if (np == 32) {
			pos[t] = 32;
			continue;
		}
		for (int j : pos) {
			if (j == np)
				return -1;
		}
		pos[t] = np;
		ret += board[np][0];
	}
	return ret;
}

void select(int p) {
	if (p == 10) {
		res = max(res, simulate());
		return;
	}
	for (int i = 0; i < 4; i++) {
		turns[p] = i;
		select(p + 1);
	}
}

int main(void) {
	cin.tie(NULL);
	ios_base::sync_with_stdio(false);

	for (int i = 0; i < 10; i++)
		cin >> moves[i];
	res = 0;
	select(0);
	cout << res << '\n';
}

// 각 칸마다 점수가 적힌 '윷놀이판'에서 다음 주사위(윷) 10회가 어떻게 나오는지 알고 있을 때, 네 개의 말로 얻을 수 있는 점수의 최댓값은?

// 순서는 정해져있지만 말이 나오는 순서는 정해져있지 않다 - 말의 순서를 dfs로 결정한 뒤, 순서대로 움직여야 함
// 유일한 제약 조건은 선택한 말을 움직일 때 도착할 칸에 다른 말이 있는 경우 - 그 경우 해당 경우의 수를 백지화하고 다시 시도해야 함(-1 리턴)
// 윷놀이 특성 상 각 칸마다 이동할 수 있는 칸이 연속적이지 않음 + 점수가 중복된 경우가 있어(22, 24, 26, 28, 30) 점수를 인덱스로 삼으면 안 됨
// 사실, 실제 윷놀이 판과 모양도 다름(대각선 길이가 다름, 시작-도착이 연속적이지 않음 등)
// 따라서 게임 판을 따로 만들어둡시다 - 각 칸에서 얻을 수 있는 점수, 1~5칸 이동 시 갈 수 있는 칸을 수동으로 기록

// 이후 계산하는 파트에서는 각 말의 위치를 저장(보드에 말의 위치를 적으려고 하니 중복 문제가 있었음)
// 겹쳐도 되는 위치는 시작(0)과 끝(32) 뿐, 그 외에 겹치는 곳이 나오면 무조건 아웃
// 따라서 가야할 곳이 끝이라면 끝점으로 이동하고 continue(점수가 없으니), 그렇지 않다면 중복 체크
// 정상적으로 이동한 후에는 해당 위치의 점수를 결과값에 누적해 최댓값을 가린다