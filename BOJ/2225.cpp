// 합분해
// https://www.acmicpc.net/problem/2225

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(void) {
	cin.tie(NULL);
	ios_base::sync_with_stdio(false);

	int n, k;
	cin >> n >> k;
	vector<vector<int>> dp(k + 1, vector<int>(n + 1));
	for (int i = 0; i <= n; i++) {
		dp[0][i] = 0;
		dp[1][i] = 1;
	}
	for (int i = 2; i <= k; i++)
		for (int j = 0; j <= n; j++)
			for (int l = 0; l <= j; l++)
				dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % 1000000000;
	cout << dp[k][n] << '\n';
}

// 0~n 범위의 정수 k개를 더해 n을 만드는 경우의 수(% 1000000000)는?

// dp 기반으로 푸는 문제 - 2차원 dp
// dp[i][j] = i개의 수로 j를 만들 수 있는 가짓수
// 따라서 dp[0][i] == 0, dp[1][i] == 1로 초기화하고 시작
// 이후 2개 이상의 수로 다른 수를 만들기 위한 점화식을 짜보자 - dp[i][j] = dp[i - 1][j - 0] + ... dp[i - 1][j - j]

// 예를 들어 n = 3, k = 3이라고 생각해보자
// dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = 0 (none)
// dp[1][0] = dp[1][1] = dp[1][2] = dp[1][3] = 1 (j)
// dp[0]과 dp[1]은 일반화가 가능
// dp[2][0] = 1 (00) = dp[1][0]
// dp[2][1] = 2 (10 01) = dp[1][0] + dp[1][1]
// dp[2][2] = 3 (20 11 02) = dp[1][0] + dp[1][1] + dp[1][2]
// dp[2][3] = 4 (30 21 12 03) = dp[1][0] + dp[1][1] + dp[1][2] + dp[1][3]
// dp[2]는 j 이하의 어떤 수를 선택한 후 더하면 j가 되는 수를 고르면 됨
// 다르게 생각하면 '1개의 수로 j 이하의 수를 만든 경우의 수'에서 j 이하의 수를 j로 만들 수 있는 수를 특정 지점에 추가한 경우의 수이므로 해당 점화식이 성립됨
// dp[3][0] = 1 (000) = dp[2][0]
// dp[3][1] = 3 (100 010 001) = dp[2][0] + dp[2][1]
// dp[3][2] = 6 (200 020 002 110 101 011) = dp[2][0] + dp[2][1] + dp[2][2]
// dp[3][3] = 10 (300 030 003 210 120 201 102 012 021 111) = dp[2][0] + dp[2][1] + dp[2][2] + dp[2][3]
// 숫자가 높아져도 이 원리는 동일함 - 'i - 1개의 수로 j 이하의 수를 만든 경우에 수'에서 해당 경우의 수에 j로 만들 수 있는 수를 삽입

// 이렇게 dp는 경우의 수들을 모두 펼치며 점화식을 짜봐야 함
// 이렇게 얻은 dp[k][n] 값이 답